#include <iostream>

using namespace std;


//Обьявим наши функции, чтобы в дальнейшем их можно было вызывать из любой части кода
void hanoi(int n, int start, int finish, int buffer);
void hanoi_n(int n, int start, int finish, int* buffers, int size_buffers);

// Итак теперь у нас есть баня Старта(start) башня конца(finish) и две баши-буффера(buffer1 и buffer2)
// n - количество колец
// start - номер начальной башни
// finish - номер конечной башни(номер башни, на которую нужно переложить кольца)
// buffer1 - номер первой вспомогательной башни - башни буффера
// buffer2 - номер второй вспомогательной башни - башни буффера
void hanoi_n(int n, int start, int finish, int buffer1, int* buffers, int size_buffers)
{
  // 1. Перекладываем самые маленькие кольца на дополнительные буфферы (start->buffers)
  for(int i=0;i<size_buffers;i++)
  {
    std::cout << start << " " << buffers[i] << '\n';
  }

  // 2. После чего забываем про второй буффер с самым маленьким кольцом и работам как и раньше с тремя оставшимися башнями
  //    Запускаем рекурсивную функцию hanoi с параметрами n-1, start, finish и первым буфером(buffer1)
  //    Почему n-1? - Потому что самое маленькое кольцо мы уже переложили на второй буффер
  hanoi(n-size_buffers,start,finish,buffer1);
  // После этого все кольца,кроме самого маленького, будут находиться на конечной башне.
  // А последнее кольцо по прежнему находиться на втором буффере
  // Для окончания алгоритма нам осталось переложить это кольцо на конечную башню, что мы и сделаем.
  // 3. Перекладываем самые маленькие кольца c дополнительных буфферов на конечную башню (buffers->finish)
  for(int i=size_buffers-1;i>=0;i--)
  {
    std::cout << buffers[i] << " " << finish << '\n';
  }
}

void hanoi(int n, int start, int finish, int buffer)
{
    //Если количество колец(n) == 0 то выходим из функции(рекурсии) под названием hanoi
    if (n==0)
    {
        return;
    }
    // Eсли количество колец на башне под номером start больше нуля то :
    else
    {
        // 1. Перекладываем n-1 колец с башни начала(start) на башню-буффер(buffer)
        hanoi(n-1,start,buffer,finish);
        //    Самое большое кольцо останеться на начальной(start) башне, а остальные перейдут на башню буффер
        // 2. После чего перекладываем самое большое кольцо с стартовой позиции на конечную (start -> finish)
        std::cout << start << " " << finish << '\n';
        //    Теперь Самое большое кольцо находится на финишной позиции, а остальные кольца на дополнительной башне(buffer)
        //    Начальная башня(start) теперь пуста
        // 3. Чтобы завершить алгоритм нам нужно переместить оставшие кольца c башни-буффера на конечную позицию
        //    Теперь в роли буффера будет выступать башня start так как она пустая,
        //    В роли стартовой башни - buffer
        //
        //    Начальная башня - buffer
        //    Конечная башня - finish
        //    Башня буффер - start
        hanoi(n-1,buffer,finish,start);
        // Итого все башни находятся на конечной башне
        // Finish!!!
    }
}

int main(int argc, char const *argv[]) {
    // Созданим переменную n, которая будет отвечать за количество колец
    int columns,
        rings,
        start=1,
        finish;

    // Выведем на экран сообщение "Введите количестов столбов"
    std::cout << "Input number of columns"<<std::endl;
    // Ожидаем от пользователя, т.е. вас, блядь. Никто кроме меня и вас не будет пользоваться этим дерьмом
    std::cin >> columns;

    // Выведем на экран сообщение "Введите количестов колец - rings"
    std::cout << "Input number of rings"<<std::endl;
    // Ожидаем от пользователя, т.е. вас, блядь. Никто кроме меня и вас не будет пользоваться этим дерьмом
    std::cin >> rings;

    // Запускаем функцию Башни Ханоя
    // Начальная позиция - start   = 1
    // Конечная позиция  - finish  = 2
    // Первый буффер     - buffer1 = 3
    // Второй буффер     - buffer2 = 4


    // Если количество столбцов меньше трех то выписываем ошибку
    if (columns<3)
      std::cout << "Number of columns is less than three" << '\n';
    else
    {
      // Выводим количество колец
      std::cout << '\n' << rings << '\n';
      // Выводим количество столбов
      std::cout << columns << '\n';
      // Это нужно для дальнейшего тестирования кода в программе Хожеля

      // Если количество столбцов равно трем то запускаем обычную функцию башни Хоноя, для трех столбов - hanoi
      if (columns==3)
      {
        hanoi(rings,1,2,3);
      }
      else if(columns>3)
      {
        int size_buffers = columns-3,
            buffers[size_buffers];
        //std::cout << "size_buffers = " << size_buffers << '\n';
        for(int i=0;i<size_buffers;i++)
        {
          buffers[i]=i+4;
        //  std::cout << i <<"  -  " << buffers[i] << '\n';
        }
        hanoi_n(rings,1,2,3,buffers,size_buffers);
      }
    }



    return 0;
}
