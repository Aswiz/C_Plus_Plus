#include <iostream>

using namespace std;


//Обьявим наши функции, чтобы в дальнейшем их можно было вызывать из любой части кода
void hanoi(int n, int start, int finish, int buffer);
void hanoi4(int n, int start, int finish, int buffer1, int buffer2);

// Итак теперь у нас есть баня Старта(start) башня конца(finish) и две баши-буффера(buffer1 и buffer2)
// n - количество колец
// start - номер начальной башни
// finish - номер конечной башни(номер башни, на которую нужно переложить кольца)
// buffer1 - номер первой вспомогательной башни - башни буффера
// buffer2 - номер второй вспомогательной башни - башни буффера
void hanoi4(int n, int start, int finish, int buffer1, int buffer2)
{
  // 1. Перекладываем самое маленькое колечко с башни start на вторую башню-буффер (start->buffer2)
  std::cout << start << " " << buffer2 << '\n';
  // 2. После чего забываем про второй буффер с самым маленьким кольцом и работам как и раньше с тремя оставшимися башнями
  //    Запускаем рекурсивную функцию hanoi с параметрами n-1, start, finish и первым буфером(buffer1)
  //    Почему n-1? - Потому что самое маленькое кольцо мы уже переложили на второй буффер
  hanoi(n-1,start,finish,buffer1);
  // После этого все кольца,кроме самого маленького, будут находиться на конечной башне.
  // А последнее кольцо по прежнему находиться на втором буффере
  // Для окончания алгоритма нам осталось переложить это кольцо на конечную башню, что мы и сделаем.
  // 3. Перекладываем самое маленькое кольцо с второго буффера на конечную башню (buffer2->finish)
  std::cout << buffer2 << " " << finish << '\n';
}


void hanoi(int n, int start, int finish, int buffer)
{
    //Если количество колец(n) == 0 то выходим из функции(рекурсии) под названием hanoi
    if (n==0)
    {
        return;
    }
    // Eсли количество колец на башне под номером start больше нуля то :
    else
    {
        // 1. Перекладываем n-1 колец с башни начала(start) на башню-буффер(buffer)
        hanoi(n-1,start,buffer,finish);
        //    Самое большое кольцо останеться на начальной(start) башне, а остальные перейдут на башню буффер
        // 2. После чего перекладываем самое большое кольцо с стартовой позиции на конечную (start -> finish)
        std::cout << start << " " << finish << '\n';
        //    Теперь Самое большое кольцо находится на финишной позиции, а остальные кольца на дополнительной башне(buffer)
        //    Начальная башня(start) теперь пуста
        // 3. Чтобы завершить алгоритм нам нужно переместить оставшие кольца c башни-буффера на конечную позицию
        //    Теперь в роли буффера будет выступать башня start так как она пустая,
        //    В роли стартовой башни - buffer
        //
        //    Начальная башня - buffer
        //    Конечная башня - finish
        //    Башня буффер - start
        hanoi(n-1,buffer,finish,start);
        // Итого все башни находятся на конечной башне
        // Finish!!!
    }
}

int main(int argc, char const *argv[]) {
    // Созданим переменную n, которая будет отвечать за количество колец
    int n;
    // Выведем на экран сообщение "Введите количестов конец - н"
    std::cout << "Input N: ";
    // Ожидаем от пользователя, т.е. вас, блядь. Никто кроме меня и вас не будет пользоваться этим дерьмом
    std::cin >> n;
    // Выводи количество колец
    std::cout << n << '\n';
    // Выводим количество башен (так как мы сейчас работаем с тремя башнями то выводим "4")
    // Это нужно для дальнейшего тестирования кода в программе Хожеля
    std::cout << "4" << '\n';
    // Запускаем функцию Башни Ханоя
    // Начальная позиция - start   = 1
    // Конечная позиция  - finish  = 2
    // Первый буффер     - buffer1 = 3
    // Второй буффер     - buffer2 = 4
    hanoi4(n,1,2,3,4);
    return 0;
}
